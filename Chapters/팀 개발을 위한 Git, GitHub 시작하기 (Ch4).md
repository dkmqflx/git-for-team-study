## Ch4

- 포크(fork)
    - 남의 원본 저장소를 내 계정의 원격 저장소로 복사해오는 명령어
    - 원본저장소 : 새로 만든 원격 저장소와 구분하기 위한 원래의 원격 저장소
    
    
    
- 기본적으로 원본 저장소에 커밋을 직접 푸시할 수 있는 사람은 원본저장소를 만든 본인(소유자)뿐이다
- 다른 사람이 푸시하기 위해서는 원본 저장소의 소유자가 이 사람을 협력자(Collaborators)로 등록해야 한다
- 하지만 원본저장소의 소유자 입장에서는 협력자가 늘어날수록 원본 저장소를 관리하기 어려워진다
- 협력자가 원본저장소에 직접 푸시할 수 있기 때문이다
- 따라서 풀 리퀘스트(Pull request)를 사용해서 이 문제를 해결한다


- 개발자는 원본저장소를 자신의 계정에 복사(fork)해서 원격 저장소를 생성하고, 이 곳에 커밋을 올린 후 원본저장소의 소유자에게 요청을 하면 원본저장소의 소유자는 개발자의 병합 요청을 검토해서 원본저장소에 반영한다
- 브랜치를 통해 코드 분기점을 만들고 풀 리퀘스트를 통해 서로 확인하고 병합하는 과정과 유사하다.
- 다만 포크한 원격 저장소의 브랜치에서 원본저장소의 브랜치로 풀 리퀘스트를 보내는 것이다

<hr>


- 포크는 브랜치를 포함한 원격저장소의 모든 커밋 이력을 새로운 원격저장소로 통째로 복사한다
- 브랜치에 올린 커밋 이력은 원본 저장소에 바로 볼 수 있는 것에 비해, 복제한 원격 저장소는 새로운 주소로 독립되었기 때문에 이곳의 이력을 보려면 추가적으로 이곳의 원격저장소 주소를 등록해야 한다


- 브랜치
    - 하나의 원본 저장소에서 분기를 나눈다
    - 하나의 원본 저장소에서 코드 커밋을 편하게 볼 수 있다
    - 다수의 사용자가 다수의 브랜치를 만들면 곤리하기 힘들다
    
    
- 포크
    - 여러 원격 저장소를 만들어 분기를 나누다
    - 원본 저장소에 영향을 미치지 않으므로 원격저장소에서 마음껏 코드를 수정할 수 있다
    - 원본저장소의 이력을 보려면 따로 주소를 추가해야 한다

<hr>

- 포크한 원격저장소에서 원본 저장소로 풀 리퀘스트를 보내서 코드를 합칠 수 있다
    - New pull request
    ![pull_request](https://user-images.githubusercontent.com/42763164/75621960-58dd8000-5bde-11ea-9d4f-00ae20fc1b8d.JPG)

- A라는 사용자가 B라는 사용자의 원격저장소를 포크한 다음 풀 리퀘스트를 보낸다
    - 그러면 B 사용자는 원본 저장소의 insight tab에서 누가 풀 리퀘스트 요청을 보냈는지 확인할 수 있다
    - Pull request 탭에서 어떠한 내용의 풀 리퀘스트 요청이 왔는지 확인할 수 있다
        - Pull request - File changed 탭에서는 어떤 새로운 코드가 이 풀 리퀘스트에 담겨 있는지 확인할 수 있다
        - 변경된 코드의 + 버튼 누르면 코드 라인 별로 댓글 달 수 있다
        - Review changes 탭을 누르면 write 창이 열린다
            - Comment : 그냥 댓글 달기
            - Approve : 댓글 달고 바로 병합해도 될 것 같을 때
            - Request changes : 수정 요청하고 싶을 때
            ![file_changed](https://user-images.githubusercontent.com/42763164/75621953-42372900-5bde-11ea-9cdc-81909eae5221.JPG)
    - Review 후에 풀 리퀘스트 하단에 댓글처럼 보여진다
    - 그 다음 Merge pull request 버튼을 눌러 풀 리퀘스트를 병합한다. 이는 원본 저장소 주인만 할 수 있다 .
    - 작업이 끝난 후 Code 탭에서 변경사항을 확인할 수 있다
- [Insights]탭의 [Contributors] 메뉴에서 원본 저장소의 컨트리뷰터를 확인할 수 있다
- 풀 리퀘스트를 보내면 이 풀 리퀘스트도 하나의 커밋으로 추가된다

<hr>

- 여러 원격저장소 히스토리를 한눈에 보는 방법 : 리모트 추가 (Add remote)
    - A의 원본저장소에서 B가 포크한 경우
        - 포크한 시점까지의 모든 히스토리는 알 수 있지만 그 다음에 원본저장소에서 무슨일이 일어났는지는 알 수 없다
        - 원본저장소와 포크한 원격저장소는 주소까지 바뀐 서로 다른 원격 저장소이기 때문이다
        - 따라서 하나의 로컬 저장소에서 두 개 이상의 원격저장소를 바라보도록 만든다
- git remote add origin 원격저장소 : origin이라는 이름으로 원격 저장소를 저장하라
- upstream : 원본저장소를 지칭하는 관용적 닉네임

    
- 패치(Fetch)
    - 새로고침 기능.
    - 패치를 하면 원본저장소 이력을 업데이트 한다
    - 패치는 이력만 가져오기 때문에 내 코드에는 아무 영향이 없다
    - cf. Pull을 하면 최신 코드를 내 코드에 반영한다

<hr>

- 풀 리퀘스트를 보냈을 때 충돌이 났을 때 해결 하는 방법
    1. 현재 커밋과 병합하고 싶은 커밋을 미리 내 브랜치에서 병합해서 병합 커밋을 만들고 이를 풀 리퀘스트로 보낸다
        - B 원격 저장소의 1번 커밋과 A 원본 저장소의 2번 커밋을 합치려고 할 때 충돌이 나는 경우

```
              (A) upstream/master
                           ↓	
                     <---커밋2
        
        커밋<----커밋<---커밋1
        				   ↑
        			   (B)master
        			
```

- 커밋1과 커밋2의 충돌을 해결해서 만들어진 커밋3(병합커밋)은 커밋 2와 문제 없이 병합할 수 있다
 - 하지만 나의 풀 리퀘스트에 불필요한 병합커밋(3번커밋)의 이력이 남아 있다
    - 이렇게 나의 풀 리퀘스트에 불필요한 병합커밋(3번커밋)의 이력이 남는 것을 해결하는 방법은 묵은 커밋을 방금 한 커밋처럼 이력을 조작하는 것이다

```
        		(A) upstream/master
        				↓							
        			<---커밋2<-------
        							 |
        커밋<----커밋<---커밋1<---커밋3
        							↑
        						(B)master

  
```

<hr>

- B는 0번 커밋으로 1번 ,2번 커밋을 만들었다
- 2번 커밋이 옛날 커밋이여서 최신 커밋인3번이랑 병합하려면 충돌이 일어난다.
- 그런데 1번, 2번 커밋을 0번 커밋이 아니라 3번 커밋을 베이스로 만들면 아무 문제 없이 Fast-forward Merge가 된다
- 이렇게 커밋의 베이스를 똑 떼서 다른 곳으로 붙여서 다시 베이스를 잡는 것을 리베이스(rebase)라고 한다

```
                                (A) upstream/master
                                            ↓							
                    <----------------------커밋3
        												
        커밋<----커밋0<---커밋1<---커밋2
                                     ↑
                                 (B)master

```

- 병합 커밋이 생기는 앞의 방법과는 달리 깔끔하게 풀 리퀘스트를 보낼 수 있다 커밋 3와 커밋 2는 아무 문제 없이 병합할 수 있다
- 간단히 정리하면 한 달 전의 코드를 기준으로 만들었던 브랜치를, 마치 최신 코드를 기준으로 만든 것 처럼 이력을 조작하는 것이다
- 만약 충돌이 있다면 이력을 조작하는 중간에 고쳐주면 된다
- upstream branch를 베이스로 삼고 재배치를 하면 아래와 결과를 얻게 된다
- 중간에 충돌이 일어나도 해결한 다음 소스트리 기준 [액션 - 재배치 계속]을 클릭해서 리베이스를 계속 진행한다
- 리베이스는 커밋을 하나씩 비교하면서 출돌이 있는지 확인하기 때문에 계속 같은 곳을 수정했다면 [재배치 계속]을 누를 때 마다 충돌이 여러번 날 수 있다

```
        			(A) upstream/master
                         ↓							
        			<---커밋3<---커밋1<---커밋2
                                           ↑
                                        (B)master
        커밋<----커밋0
        												
```
- 이후 푸시를 해서 로컬 저장소의 이력을 원격저장소에 반영해야 한다
- 하지만 리베이스는 이력을 조작하기 때무넹 일반 푸시로는 수행할 수 없다
- 따라서 리베이스를 사용하면 강제 푸시를 사용해서 원격 저장소에 반영해야 한다
- 리베이스는 히스토리를 강제로 조작하기 때문에 반드시 혼자만 쓰는 브랜치에서 수행해야 한다

## Refernece
- [팀 개발을 위한 Git, GitHub 시작하기](http://www.hanbit.co.kr/store/books/look.php?p_code=B5159933380)
