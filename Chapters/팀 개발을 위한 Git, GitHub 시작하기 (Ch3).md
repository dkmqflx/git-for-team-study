## Ch3

- 커밋은 줄줄이 기차처럼 연결되어 있다
- 특정 기준에서 줄기를 나누어 작업할 수 있는 기능을 브랜치(Branch)라고 한다
- 새로운 가지로 커밋을 만들려면 반드시 브랜치를 먼저 만들어야 한다

```
									 <------ A가 수정한                                                                                                                                1월 6일 버전

    
    		커밋1      <-------     커밋2         <-------     커밋3 
     (1월 2일 버전)           (1월 3일 버전)             (1월 4일 버전)
    
    
									    <------ B가 수정한
									            1월 6일 버전
    																															
    # 1월 6일 버전 둘다 커밋 3를 가르키고 있다
```

<hr>

- [master]는 Git이 제공하는 기본적인 브랜치
- 첫 번째 커밋을 하면 자동으로 'master'라는 이름의 브랜치가 커밋을 가리키게 된다
- 브랜치는 단순한 포인터(Pointer)이다.

```
  commit 1                              commit 1 <------ commit 2
     ↑                 ========>                             ↑ 
(master branch)       새로운 커밋 추가                    (master branch)

````

<hr>

```
                                                               (A branch)
    								    ↓
    		커밋1      <-------     커밋2         <-------     커밋3 
     (1월 2일 버전)           (1월 3일 버전)             (1월 4일 버전)
    								↑
    						         (master branch)
    								↑
    								HEAD
```
- 브랜치는 포인터 이기 때문에 커밋을 가리키는 것만으로도 분기를 만들 수 있다
- A 브랜치에 커밋을 하나 더 하면 master 브랜치 보다 커밋 하나만큼 앞서게 된다
- A 브랜치와 master 브랜치는 [HEAD]라는 특수한 포인터를 사용해서 넘나들 수 있다
- [HEAD]는 브랜치 혹은 커밋을 가리키는 포인터이다.
- [HEAD] 포인터가 [master] 브랜치를 가르키면 커밋2의 상태 보여주고 A branch를 가리키면 커밋3의 상태를 보여준다
- 브랜치의 최신 커밋이 아닌 과거 커밋으로도 [HEAD]를 이동시킬 수 있는데 이 경우에는 [maseter]브랜치의 포인터와 [HEAD]가 떨어져 있기에 '분리된 HEAD(Detached HEAD)' 상태가 된다


<hr>

- 여러 버전이 꼬이는 것을 방지하기 위해서 하나의 브랜치에는 한 사람만 작업해서 올리는 것이 바람직하다.
    1. [master] 브랜치에는 직접 커밋을 올리지 않는다 (동시에 작업하다 꼬일 수 있다)
    2. 기능 개발을 하기 전에 [master]브랜치 기준으로 새로운 브랜치를 만든다
    3. 이 브랜치의 이름은 [feature/기능이름] 형식으로 하고 한 명만 커밋을 올린다
    4. [feature/기능이름] 브랜치에서 기능 개발이 끝나면 [master] 브랜치에 이를 합친다

<hr>

- 병합(merge)는 간단히 말해서 두 버전의 합집합을 구하는 것이다
    1. Merge commit(병합 커밋) : +A U A* = +A*
    2. Fast-forward(빨리 감기) : A U B = B
        - 합친 결과물이 B와 동일하기 때문에 새로 상태를 만들어 줄 필요 없이 B로 상태를 바꿔주면 된다
    3. Conflict(충돌) : A+ U A* = A+? A*?
        - 무엇을 기준으로 합쳐야할지 모르기 때문에 충돌이 난 부분만 확인하고 무엇을 남길지 수동으로 선택해 주면 된다
    

<hr>

```
                         <------  커밋3    <------ 커밋4 <-(feture/detail-page 브랜치)

    
    커밋1      <-------    커밋2    <-------------------------------     커밋5     
                             ↑                                           ↑
                        (master branch)                            (feature/cart 브랜치)
                        
```

- 커밋 4는 커밋2를 단순하게 수정한 최신본이기 때문에 두 상태를 합치면 바뀌는 상태 없이 커밋 4가 될 것이다 : Fast-forward
- 따라서 merge 후에 marster branch와 feature/detail-page 브랜치는 커밋 4를 가리키게 된다
- 커밋 5는 커밋 2를 중심으로 상태가 바뀌었기 때문에 커밋4에 있는 master 브랜치와 커밋5에 있는 feature/cart 를 합치게 되면 merge commit이 된다
- [master] 브랜치를 기준으로 병합한다는 것은 합친 결과물을 [master]브랜치에 반영한다는 것이다
- A와 B브랜치가 있을 때 두 개를 합쳤을 때 만들어진 AB브랜치를 A 브랜치에 올릴 건지, B 브랜치에 올릴 것인지 정하는 것이다.
- 만약  A 브랜치에 올린다면 AB브랜치가 A 브랜치에만 반영되고 B 브랜치에는 반영이 안된다

```
#1. master를 베이스로 병합
	
                                            (master)
                                                ↓
			A <-------------------- AB 
			
			
			B<---------------------
			↑                           				          
               (feature branch)


#2. feature를 베이스로 병합
	
	 (master)
			↓
			A <-------------------- 
			
			
			B<--------------------- AB
                                    ↑                           				      
                               (feature branch)  

```

<hr>

- 두 커밋이 같은 코드를 수정했다면 병합 커밋을 만들다가 충돌이 날 가능성이 있다
- 그래서 동료들과 같이 쓰는 [master] 브랜치에 바로 병합하지 않고 나만 쓰는 [feature/cart]에서 먼저 병합해보고 문제가 없는지 확인한다


- 1단계 : master 브랜치를 땡겨와서 feature/cart 브랜치에서 병합한다

```
                                     (master branch)
                                            ↓
		<------  커밋2    <------ 커밋3 <----------------------
                                                                     |
                                                                     |
                                                                     |
   커밋1    <-------------------------------   커밋4     <------  병합 커밋
                                                                     ↑
                                                          (feature/cart 브랜치)


```

- 2단계: feature/cart 브랜치에서 병합한 커밋을 master 브랜치에 반영한다

```
                   <------  커밋2    <------ 커밋3 <- <---------------------
                                                                            |
                                                                    (master branch)
                                                                           ↓

       커밋1    <-------------------------------   커밋4     <------  병합 커밋
                                        ↑                           	↑
    				 (master branch)                 (feature/cart 브랜치)
```

<hr>

- 풀 리퀘스트 (Pull request)
    - 협력자에게 브랜치 병합을 요청하는 메세지를 보내는 것
- 베이스 브랜치(base brach) : 병합 결과물이 올라갈, 즉 기준이 되는 브랜치
- 비교 브랜치 (compare brach) : 기준 브랜치의 비교대상이 되는 브랜치. 내가 만들어서 base 브랜치에 반영시키고 싶은 브랜치


![_2020-02-18__1 29 01](https://user-images.githubusercontent.com/42763164/75544419-45f46f80-5a67-11ea-9316-025200bd1e61.png)



- Assigners : 이 풀 리퀘스트를 담당하는 동료. 보통 자기 자신
- Labels : 이 풀 리퀘스트에 관한 라벨을 달아준다. 예를들어 [프론트엔드], [백엔드]
- Pull은 실제 코드를 내려 받는데 비해 패치는 그래프만 업데이트 한다.
- 풀 리퀘스트는 코드의 라인마다 댓글을 달 수 있다.
- 따라서 해당 코드가 왜 고쳐졌는지, 혹은 어떻게 개선할 수 있는지 풀 리퀘스트 내부에서 토론을 진행할 수 있다
- 이 풀 리퀘스트에 대해서 수락(Accept), 수정 요청(Request), 병합(Merge pull request) 할 수있다
- 그림처럼 master 브랜치에 풀 리퀘스트를 하고 병합을 하면 새로운 병합 커밋이 생기고 master 브랜치가 그 커밋을 가르키게 된다
- 하지만 소스트리를 쓸 때 즉시 반영이 되지 않는 경우가 있는데 이때 [패치] 기능을 사용해서 Git에서 새로운 이력을 업데이트 한다
- Pull은 실제 코드를 내려 받는데 비해 패치는 그래프만 업데이트 한다

<hr>

- 버전을 올리는 것은 메이저 업그레이드와 마이너 업그레이드로 나뉜다
    - 메이저 업그레이드 : 사람들이 크게 느낄 변화를 적용(v2.x → v3.x)
    - 마이너 업그레이드 : 작은 변화 등이 있을 때 (v.2.3 → v.2.4)
- 릴리즈(release)
    - 프로그램을 출시하는 것
- 태그
    - 새로운 프로그램을 출시하고 현재 코드 상태를 버전 v1.0.0이라고 기록할 때 이를 태그를 통해서 간단하게 표시할 수 있다
    - 브랜치 처럼 커밋을 가리키는 가벼운 포인터이다
    - 태그도 브랜치처럼 푸시를 해주어야 원격저장소에서도 볼 수 있다

## Refernece
- [팀 개발을 위한 Git, GitHub 시작하기](http://www.hanbit.co.kr/store/books/look.php?p_code=B5159933380)


```python

```
